<!DOCTYPE html>
<html>
  <head>
    <title>My Portfolio</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f9f9f9;
        color: #333;
        line-height: 1.6;
      }
      nav ul {
        list-style: none;
        padding: 0;
        margin-bottom: 20px;
      }
      nav ul li {
        display: inline;
        margin-right: 15px;
      }
      nav a {
        text-decoration: none;
        color: #0066cc;
      }
      nav a:hover {
        text-decoration: underline;
      }
      section {
        margin-bottom: 40px;
        padding: 20px;
        background: #ffffff;
        border-radius: 6px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      }
      h1, h2, h3, h4 {
        color: #004080;
        margin-top: 1.2em;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }
      table, th, td {
        border: 1px solid #ccc;
      }
      th, td {
        padding: 8px;
        text-align: left;
      }
      details {
        margin-bottom: 1em;
      }
      summary {
        font-weight: bold;
        cursor: pointer;
        margin-bottom: 0.5em;
      }
      code {
        background: #eee;
        padding: 2px 4px;
        border-radius: 4px;
        display: block;
        margin: 10px 0;
        white-space: pre-wrap;
      }
      pre {
        background: #f4f4f4;
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
      }
      a {
        color: #0066cc;
      }
    </style>
  </head>
  <body>

    <!-- Navigation Menu -->
    <nav>
      <ul>
        <li><a href="#introduction">Introductions</a></li>
        <li><a href="#projects">Projects</a></li>
        <li><a href="#reflections">General Reflections</a></li>
      </ul>
    </nav>

    <section id="introduction">
      <h1>Welcome to My Portfolio</h1>
      <p>Hi, I'm <strong>Sean Tai Han Xuan</strong>, a computer science student passionate about hands-on projects, applying theoretical knowledge to real life, and building smart systems that bridge the digital and physical worlds.</p>
    
      <p>This portfolio showcases my learning journey, including:</p>
      <ul>
        <li>Hands-on Arduino research and experiments</li>
        <li>App development projects and code samples</li>
        <li>Weekly reflections and personal insights</li>
        <li>Links to my resume, GitHub, and more</li>
      </ul>
    
      <p>The purpose of this site is to document my growth, demonstrate my skills, and share what I’m working on — whether it’s for internships, mentors, or just curious visitors.</p>
    </section>

    <!-- Projects Section -->
    <section id="projects">
      <h2>Projects</h2>
      <ul>
        <li><a href="#arduino">Arduino Project</a></li>
        <li><a href="#app">App Development</a></li>
      </ul>
    </section>

    <!-- Arduino Project Subsection -->
    <section id="arduino">
      <h3>Arduino Project</h3>
    
      <h4 id="arduino-part1">Part 1 - Getting Familiar with the Arduino Board</h4>
        <p>I learned about how each pin functions by using the Arduino board manual and online resources.</p>

        <details>
          <summary><strong>Arduino Pins</strong></summary>
        
          <p><strong>GND Pins:</strong> Provide a common ground to complete electrical circuits.</p>
        
          <details>
            <summary><strong>Analog Section (A0-15)</strong></summary>
            <p><strong>Description:</strong> These pins read analog signals and convert them into digital values.</p>
            <ul>
              <li><strong>Function:</strong> Reads varying voltages from sensors (0V-5V).</li>
              <li><strong>ADC:</strong> 10-bit resolution converts 0V to 0 and 5V to 1023.</li>
              <li><strong>Analog Signals:</strong> Continuous voltage values (unlike digital signals).</li>
            </ul>
          </details>
        
          <p><strong>AREF Pin (Analog Reference):</strong> Allows custom reference voltage for ADC (default 5V = 1023).</p>
          <ul>
            <li>Use a different voltage (e.g. 2.5V) for higher accuracy in low-voltage sensors.</li>
            <li><strong>Warning:</strong> Too low a voltage may cause loss of resolution and noisy readings.</li>
          </ul>
        
          <p><strong>Digital Pins (D22-53):</strong> For basic HIGH/LOW logic I/O control.</p>
          <ul>
            <li><strong>HIGH:</strong> 5V output</li>
            <li><strong>LOW:</strong> 0V output</li>
            <li>Used for controlling components like LEDs, buttons, and more.</li>
          </ul>
        
          <p><strong>TX Pins (TX0-TX3):</strong> Transmit data (UART protocol)</p>
          <p><strong>RX Pins (RX0-RX3):</strong> Receive data</p>
          <ul>
            <li>Each TX/RX pair maps to Serial, Serial1, Serial2, Serial3</li>
            <li><strong>Protocol:</strong> UART (Start bit, 8 data bits, Stop bit)</li>
            <li><strong>Bit-by-bit transmission</strong> with baud rate defining speed</li>
          </ul>
        
          <p><strong>I2C Communication:</strong></p>
          <ul>
            <li><strong>SDA (Serial Data):</strong> Carries bidirectional data</li>
            <li><strong>SCL (Serial Clock):</strong> Master-generated clock syncs data timing</li>
          </ul>
        
          <p><strong>PWM Pins (Pin 2–13):</strong> Marked with "~", simulate analog output via PWM.</p>
        
          <details>
            <summary><strong>Timer Comparison (PWM Support)</strong></summary>
            <table border="1" cellpadding="8" style="border-collapse: collapse; margin-top: 10px;">
              <tr>
                <th>Timer</th>
                <th>Bit Resolution</th>
                <th>Count Range</th>
                <th>Special Functions</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>Timer 0</td>
                <td>8-bit</td>
                <td>0-255</td>
                <td>Basic timing, PWM</td>
                <td>General-purpose PWM and delay.</td>
              </tr>
              <tr>
                <td>Timer 1</td>
                <td>16-bit</td>
                <td>0-65,535</td>
                <td>High-resolution PWM, Input Capture</td>
                <td>Precise timing and external pulse measurement.</td>
              </tr>
              <tr>
                <td>Timer 2</td>
                <td>8-bit</td>
                <td>0-255</td>
                <td>Basic timing, PWM</td>
                <td>Similar to Timer 0.</td>
              </tr>
              <tr>
                <td>Timer 3</td>
                <td>16-bit</td>
                <td>0-65,535</td>
                <td>High-resolution PWM, Output Compare</td>
                <td>Advanced timing and wave control.</td>
              </tr>
              <tr>
                <td>Timer 4</td>
                <td>16-bit</td>
                <td>0-65,535</td>
                <td>High-resolution PWM</td>
                <td>Same capabilities as Timer 3.</td>
              </tr>
            </table>
          </details>
        
          <p><strong>IOREF Pin:</strong> Tells connected devices what voltage (3.3V/5V) the board uses for logic.</p>
        
          <p><strong>Power Pins:</strong></p>
          <ul>
            <li><strong>Vin:</strong> Supply external voltage (battery, adapter)</li>
            <li><strong>3.3V Pin:</strong> Outputs regulated 3.3V</li>
            <li><strong>5V Pin:</strong> Outputs 5V from USB or regulator</li>
            <li><strong>Use correct voltage:</strong> Overvoltage can damage components.</li>
          </ul>
        
          <p><strong>Reset Pin:</strong> Restarts the microcontroller.</p>
        
        </details>
                <summary><strong>Timer Comparison</strong></summary>
                <table border="1" cellpadding="8" style="border-collapse: collapse; margin-top: 10px;">
                  <tr>
                    <th>Timer</th>
                    <th>Bit Resolution</th>
                    <th>Count Range</th>
                    <th>Special Functions</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Timer 0</td>
                    <td>8-bit</td>
                    <td>0 to 255</td>
                    <td>Basic timing, PWM</td>
                    <td>Used for general-purpose timing and PWM.</td>
                  </tr>
                  <tr>
                    <td>Timer 1</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>High-resolution timing and precise PWM.</td>
                  </tr>
                  <tr>
                    <td>Timer 2</td>
                    <td>8-bit</td>
                    <td>0 to 255</td>
                    <td>Basic timing, PWM</td>
                    <td>Similar to Timer 0, used for PWM generation.</td>
                  </tr>
                  <tr>
                    <td>Timer 3</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>Advanced timing and PWM capabilities.</td>
                  </tr>
                  <tr>
                    <td>Timer 4</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>Similar to Timer 3, provides high-resolution PWM.</td>
                  </tr>
                </table>
              </details>

              <br>

              <p><strong>IOREF Pin:</strong> Provides the reference voltage for the board's input/output pins (typically 5V), letting external components know the board's <strong>logic voltage</strong>. This is important because different devices may operate at different logic levels (e.g. 3.3V or 5V), and the pin helps them adapt to the correct voltage.</p>
              <p><strong>Logic Voltage:</strong> The voltage levels used to represent digital signals (1/0), where "high" is typically 5V and 'low' is 0V, ensuring safe communication and prevents potential damage from voltage mismatches.</p>

              <br>

              <p><strong>Vin Pin:</strong> Used to supply external power to Arduino Mega 2560. Can also connect a power source like battery or an external power adapter to this pin.

              <br>
              
              <p><strong>3.3V Pin:</strong> Provides a regulated 3.3V output for powering components, or sensors that operate at lower voltages.</p>
              <p><strong>5V Pin:</strong> Supplies a regulated 5V output to power external components or sensors that require 5V to operate. This pin is powered either through USB connection or via voltage regulator when the board is powered through the Vin Pin, providing a stable 5V, making it convenient for powering devices directly from the board without needing an additional power supply.</p>
              <p>Some devices require lower voltage, so higher voltage might damage them.</p>

              <br>

              <p><strong>Reset Pin:></strong> Reset the microcontroller on the Arduino Mega 2560.</p>
          </details>
    
      <h4 id="arduino-part2">Part 2 - Testing Basic Code</h4>
        <p>I practiced 3 simple Arduino sketches using analogRead.</p>
          <details>
            <summary><strong>Code 1: BMP 280 Sensor Test</strong></summary>
              <p><strong>Summary:</strong> Sense surrounding temp. & Pressure
              <details>
                <summary><strong>All Pins:</strong></summary>
                <p><strong>VIN Pin:</strong> Used to connect the sensor to a power supply (typically 3.3V-5V). This pin provides </p>
              </details>
              <p><strong>Setup:</strong> Connect the BMP 280 Sensor to the breadboard. Place the jumper wire into the breadboard slot next to the sensor's pin. Then, </p>
              <p><strong>(Power)5V:</strong> VIN, <strong>(Power)GND:</strong> GND, <strong>(PWM)10:</strong> CS, <strong>(PWM)11:</strong> SDI, <strong>(PWM)12</strong> SDO, <strong>(PWM)13</strong> SCK.</p>
              <pre><code>
          void setup() {
            Serial.begin(9600);
          }
          
          void loop() {
            int sensorValue = analogRead(A0);
            Serial.println(sensorValue);
            delay(1000);
          }
              </code></pre>
          
              <p><strong>Result:</strong> 19:36:09.167 -> Temperature = 22.46 *C <br/> 19:36:09.167 -> Pressure = 101981.96 Pa <br/> 19:36:09.199 -> Approx altitude = -54.55 m</p>
              </details>
            <details>

            <summary><strong>Code 2: LED Backpack Counter Test</strong></summary>
              <p><strong>Setup:</strong> Same sensor, LED connected to pin 13.</p>
              <pre><code>

              #include <Wire.h>
              #include <TimerOne.h> // Timer1 documentation: https://www.pjrc.com/teensy/td_libs_TimerOne.html
              #include <Adafruit_LEDBackpack.h> // Search Arduino Library manager for "Adafruit LED Backpack Library“ for 7-segment LED.
              
              Adafruit_7segment matrix = Adafruit_7segment();
              unsigned int timerCount = 0; // global variable needed to increment by one
              void secondElapsed() {
                timerCount++;
                matrix.print(timerCount);
              }

              void setup() {
                matrix.begin(0x70); // Creates a serial connection to 7-segment display with the address "0x70"
                Timer1.initialize(1000000); // Initializes the timer to count every 1 000 000 microseconds i.e. one second
                Timer1.attachInterrupt(secondElapsed); // Triggers interrupt every time timer counts
              }

              void loop() {
                matrix.writeDisplay();
              }
                  
              </code></pre>
            <p><strong>Result:</strong> LED turns on when sensor value crosses 500.</p>
            </details>
          
            <details>
            <summary><strong>Code 3: GPS Module Test</strong></summary>
              <p><strong>Setup:</strong></p>
              <pre><code>
#define PPS_PIN 2 // The pin we're attaching to the PPS signal from the GPS unit
 volatile unsigned int overflows = 0;
 volatile unsigned int overflowsSincePPS = 0;
 volatile unsigned int lastTimer1 = 0;
 volatile bool recentPPS = false;
 ISR(TIMER1_OVF_vect) // This is called whenever Timer/Counter 1 overflows
{
 overflows++; // Increases the "overflows" variable by 1
}
void setup() {
 Serial.begin(115200);
 delay(1000);
 pinMode(PPS_PIN, INPUT);
 TCCR1A = 0; // Sets entire TCCR1A--Timer1 Control Register A--to 0
 TCCR1B = bit(CS10); // Turns on the Timer1 clock and sets it to increment every clock cycle 
 TCCR1C = 0; // Timer 1 Control Register C set to 0
 TCNT1 = 0; // Initialize timer/counter 1's value to 0
 TIMSK1 = bit(TOIE1); // Timer/Counter1's interrupt mask register; TOIE1 is the timer/Counter1 overflow interrupt enable
 Serial.println("Starting up...");
 attachInterrupt(digitalPinToInterrupt(PPS_PIN), PPSHandler, RISING);
}
void PPSHandler() { // Since this is an interrupt we should do as little as possible here. Serial writes take a lot of clock cycles, so we save that for the loop.
 lastTimer1 = TCNT1; 
 TCNT1 = 0; // Resets Timer1 Count
 overflowsSincePPS = overflows;
 overflows = 0;
 recentPPS = true;
}
void loop(){
 if (recentPPS) {
  noInterrupts();
  uint32_t overflowsTemp = overflowsSincePPS;
  uint32_t lastTimerTemp = lastTimer1;
  interrupts();
  Serial.print("Overflow:");
  Serial.println(overflowsTemp);
  Serial.print("Timer1:");
  Serial.println(lastTimerTemp);
  Serial.print("ClockCycles:");
  Serial.println(overflowsTemp << 16 | lastTimerTemp); // Equivalent to overflowsTemp * 2^16 + lastTimerTemp
 recentPPS = false;
 }
}

              </code></pre>
            <p><strong>Result:</strong> </p>
            </details>

            <details>
            <summary><strong>Code 4: Pulse Generator Test</strong></summary>
              <p><strong>Setup:</strong></p>
              <pre><code>
                #include <SPI.h> // Allows you to communicate with SPI (Serial Peripheral Interface) devices, with the Arduino as the master device
                  #include <Wire.h> // Enable this line if using Arduino Uno, Mega, etc.
                  // Signal pins are given a name, Global variables
                  #define triggerPin 2 // Trigger signal pin
                  // Interrupt service routine
                  // This function must be implemented, so that the TCNT1 counter counts
                  ISR(TIMER1_OVF_vect)
                  {
                  }
                  // All Arduino programs must contain a setup() and loop() functions
                  void setup() {
                  Serial.begin(115200); // Starts the serial monitor, sets baudrate to "115200" BPS
                  pinMode(triggerPin,INPUT); // Sets the digital pin 2 as an input
                  delay(1000); // Pauses the program for one second at the moment of open
                  // Initializes the Timer1 registers (16-bit timer -- counts from 0 to 65535 ad nauseam). Timer interrupts/pauses the execution of the loop() function for a predefined number of seconds.
                  // Timer1 is a 16-bit timer, so the timer will increase its value until it reaches its maximum count before reverting to 0. This enables the program to run a different set of commands. Once executed, the program resumes at the same position.
                  TCCR1A = 0; // Sets entire TCCR1A--Timer1 Control Register A--to 0
                  TCCR1B = 0; // Timer 1 Control Register B set to 0 (The physical address of timer1)
                  TCCR1C = 0; // Timer 1 Control Register C set to 0
                  TCNT1 = 0; // Initialize timer/counter 1's value to 0
                  TIMSK1 = _BV(TOIE1); // Timer/Counter1's interrupt mask register; TOIE1 is the timer/Counter1 overflow interrupt enable
                  TCCR1B = 1; // Timer 1 Control Register B set to 1
                  attachInterrupt(digitalPinToInterrupt(triggerPin), Trigger, RISING); // Interrupts execution of the program when a trigger signal is received. The "Trigger" function is subsequently executed
                  }
                  void Trigger(){
                  unsigned int temp = TCNT1; // Only positive integers are required
                  Serial.print("TCNT1 value: ");
                  Serial.println(temp); // Prints the value stored at temp
                  }
                  void loop() {
                  // No lines are necessary here
                  }
                             
              </code></pre>
            <p><strong>Result:</strong></p>
            </details>
    
      <h4 id="arduino-part3">Part 3 - Examining Relationship Between Baud Rate and Accuracy</h4>
      <p>Using the Pulse Generator Test code to adjust the baud rate and the frequency from the pulse generator.</p>
      <p>Below is the poster I presented in Queensborough Community College Undergraduate Research Day</p>
      <p><a href="SeanTai_ArduinoResearchPPT.pdf" target="_blank">View Arduino Research Slides (PDF)</a></p>
      <p>After this step, I noticed a pattern of patterns like shown below</p>

      <p>Then I used the code below to test</p>]
      <pre><code>

      </code></pre>


      <h4 id="arduino-part4">Part 4 - Measuring The Voltage</h4>
      <p>...</p>
      
      <h4>Reflection</h4>
      <p>This multi-part journey helped me understand hardware and C++ better.</p>
    </section>



    <!-- App Project Subsection -->
    <section id="app">
      <h3>App Development</h3>
      <p>Details about your app development project...</p>
      <h4>Reflection</h4>
      <p>Your reflection about the app development project goes here.</p>
    </section>

    <!-- General Reflections Section -->
    <section id="reflections">
      <h2>General Reflections</h2>
      <p>Other reflections or insights can be placed here.</p>
    </section>

  </body>
</html>