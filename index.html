<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>My Portfolio - Sean Tai Han Xuan</title>
    <link rel="stylesheet" href="style.css">
  </head>
<body>

  <nav>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#projects">Projects</a></li>
      <li><a href="#reflections">Reflections</a></li>
    </ul>
  </nav>

  <section id="introduction">
    <h1>Welcome to My Portfolio</h1>
    <p>Hi, I'm <strong>Sean Tai Han Xuan</strong>, a CS student passionate about bridging theory and practice through hands-on tech projects.</p>
    <p>This site includes:</p>
    <ul>
      <li>Arduino research and experiments</li>
      <li>App development progress</li>
      <li>Weekly reflections and insights</li>
      <li>Resume, GitHub, and LinkedIn links</li>
    </ul>
    <p>It’s a space to showcase my learning journey and growth to mentors, recruiters, and curious visitors.</p>
  </section>

  <!-- Your project and reflections sections go here exactly as before -->
  <!-- Replace the rest of your previous content from <section id="projects"> onward here -->
  
</body>
</html>
    <!-- Projects Section -->
    <section id="projects">
      <h2>Projects</h2>
      <ul>
        <li><a href="#arduino">Arduino Project</a></li>
        <li><a href="#app">App Development</a></li>
      </ul>
    </section>

    <!-- Arduino Project Subsection -->
    <section id="arduino">
      <h3>Arduino Project</h3>
    
      <h4 id="arduino-part1">Part 1 - Getting Familiar with the Arduino Board</h4>
        <p>I learned about how each pin functions by using the Arduino board manual and online resources.</p>

        <details>
            <summary><strong>Arduino Pins</strong></summary>
              <p><strong>GND Pins:</strong> Complete the electrical circuit by providing a common ground.</p>
              <details>
                <summary><strong>Analog Section (A0–15)</strong></summary>
                <p><strong>Description:</strong> These pins are used for reading analog input signals and converting them into digital values that the microcontroller can process.</p>
              
                <ul>
                  <li><strong>Function:</strong> Read varying voltage levels from input devices (e.g. sensors, temp. sensors) between 0V and 5V.</li>
                  <li><strong>Analog-to-Digital Conversion (ADC):</strong> 10-bit ADC converts input to a value between 0 and 1023 (0V = 0, 5V = 1023).</li>
                  <li><strong>Analog input signals:</strong> Continuous signals with a range of values, unlike binary digital signals.</li>
                </ul>
              </details>

              <details>
                <summary><strong>AREF Pin</strong></summary>
                <p><strong>AREF pin (Analog Reference Pin):</strong> Used to set a custom reference voltage from ADC (Default: 5V = 1023). </p>
                <p>We can adjust the voltage (typically 1.1V and 5V) by connecting a different voltage to AREF to improve accuracy.</p>
                <p><strong>Example:</strong> If sensor outputs a maximum of 2.5V, we can set AREF to 2.5V.</p>
                <p><strong>Setting AREF voltage too low would reduce the resolution significantly and might result in unusable or noisy data.</strong></p>
              </details>
              
              <details>
                <summary><strong>Digital Pins</strong></summary>
                <p><strong>Digital Pins:</strong> Used for basic input/output of digital signals (HIGH = ON, LOW = OFF).</p>
                <ul>
                  <li><strong>Pins (D22-53):</strong> Can be used as digital inputs and outputs.</li>
                  <li><strong>HIGH/LOW Logic:</strong> Output 5V when set to HIGH and 0V when set to LOW.</li>
                </ul>
                <p><strong>Digital pins can be utilized by code written in Arduino IDE to control the function of external components.</strong></p>
              </details>

              <details>
                <summary><strong>TX/RX Pin</strong></summary>
                <p><strong>TX Pins (TX0-3):</strong> Used to transmit data from the Arduino to other devices. Each pin corresponds to a specific serial port: TX0 -> Serial, TX1 -> Serial1...</p>
                <p><strong>RX Pins (RX0-3):</strong> Used to receive data from external devices into Arduino. Each pin corresponds to a specific serial port: RX0 -> Serial, RX1 -> Serial1...</p>
                <p>When receiving data, it enters the Arduino through the appropriate RX pin, allowing microcontroller to process the data.</p>
                <p>When sending data, it sends the data through appropriate TX pin, which can be connected to the RX pin of another device for communication.</p>
                <p>All TX pins operate using the same communication protocol (UART), which means they transmit all the data in the same format (Start-bit, 8bits of data, Stop-bit).</p>
                <p><strong>Bit-by_Bit Transmission:</strong> In serial communication, data is transmitted one bit after another.</p>
                <p><strong>Start and Stop Bits:</strong> In asynchronous serial communication, each data packet typically starts with a start bit and ends with one or more stop bits. So receiving device know when to start and stop reading incoming data.</p>
                <p><strong>Data Rate:</strong> Serial communication is characterized by its baud rate, which is the number of signal changes or symbols sent per second (Speed of data transmission).</p>
              </details> 

              <details>
              <summary><strong>SDA/SCL Pin</strong></summary>
                <p><strong>SDA Pin:</strong> SDA pin is the Serial Data used for I2C (Inter-Integrated Circuit) communication, responsible for carrying the data being transmitteed between the master device and one or more slave devices. <strong>SDA line is bidirectional.</strong></p>
                <p><strong>SCL Pin:</strong> SCL pin is the Serial Clock Line for I2C, providing the clock signal that synchronizes the data transmission over the SDA line. The master device generates the clock signal on the SCL pin, which ensures that both the master and slave devices are <strong>synchronized</strong> in terms of timing during data exchange.<strong>Essential for coordinating when data bits are read from or written to the SDA line.</strong></p>
              </details>

              <details>
              <summary><strong>PWM Pins</strong></summary>
              <p><strong>PWM Pins (Pin2-13):</strong> Marked with "~", these allow analog-like output.</p>
              <details>
                <summary><strong>Timer Comparison</strong></summary>
                <table border="1" cellpadding="8" style="border-collapse: collapse; margin-top: 10px;">
                  <tr>
                    <th>Timer</th>
                    <th>Bit Resolution</th>
                    <th>Count Range</th>
                    <th>Special Functions</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Timer 0</td>
                    <td>8-bit</td>
                    <td>0 to 255</td>
                    <td>Basic timing, PWM</td>
                    <td>Used for general-purpose timing and PWM.</td>
                  </tr>
                  <tr>
                    <td>Timer 1</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>High-resolution timing and precise PWM.</td>
                  </tr>
                  <tr>
                    <td>Timer 2</td>
                    <td>8-bit</td>
                    <td>0 to 255</td>
                    <td>Basic timing, PWM</td>
                    <td>Similar to Timer 0, used for PWM generation.</td>
                  </tr>
                  <tr>
                    <td>Timer 3</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>Advanced timing and PWM capabilities.</td>
                  </tr>
                  <tr>
                    <td>Timer 4</td>
                    <td>16-bit</td>
                    <td>0 to 65,535</td>
                    <td>Input capture, output compare, high-resolution PWM</td>
                    <td>Similar to Timer 3, provides high-resolution PWM.</td>
                  </tr>
                </table>
              </details>
              </details>

              <details>
              <summary><strong>IOREF Pin</strong></summary>
              <p><strong>IOREF Pin:</strong> Provides the reference voltage for the board's input/output pins (typically 5V), letting external components know the board's <strong>logic voltage</strong>. This is important because different devices may operate at different logic levels (e.g. 3.3V or 5V), and the pin helps them adapt to the correct voltage.</p>
              <p><strong>Logic Voltage:</strong> The voltage levels used to represent digital signals (1/0), where "high" is typically 5V and 'low' is 0V, ensuring safe communication and prevents potential damage from voltage mismatches.</p>
              </details>

              <details>             
              <summary><strong>Vin and two V Pins</strong></summary> 
              <p><strong>Vin Pin:</strong> Used to supply external power to Arduino Mega 2560. Can also connect a power source like battery or an external power adapter to this pin.</p>
              <p><strong>3.3V Pin:</strong> Provides a regulated 3.3V output for powering components, or sensors that operate at lower voltages.</p>
              <p><strong>5V Pin:</strong> Supplies a regulated 5V output to power external components or sensors that require 5V to operate. This pin is powered either through USB connection or via voltage regulator when the board is powered through the Vin Pin, providing a stable 5V, making it convenient for powering devices directly from the board without needing an additional power supply.</p>
              <p>Some devices require lower voltage, so higher voltage might damage them.</p>
              </details>
              
              <details>
              <summary><strong>Reset Pin</strong></summary>
              <p><strong>Reset Pin:></strong> Reset the microcontroller on the Arduino Mega 2560.</p>
              </details>
          </details>
    
      <h4 id="arduino-part2">Part 2 - Testing Basic Code</h4>
        <p>I practiced 3 simple Arduino sketches using analogRead.</p>
          <details>
            <summary><strong>Code 1: BMP 280 Sensor Test</strong></summary>
              <p><strong>Summary:</strong> Sense surrounding temp. & Pressure
              <details>
                <summary><strong>All Pins:</strong></summary>
                <p><strong>VIN Pin:</strong> Used to connect the sensor to a power supply (typically 3.3V-5V). This pin provides </p>
              </details>
              <p><strong>Setup:</strong> Connect the BMP 280 Sensor to the breadboard. Place the jumper wire into the breadboard slot next to the sensor's pin. Then, </p>
              <p><strong>(Power)5V:</strong> VIN, <strong>(Power)GND:</strong> GND, <strong>(PWM)10:</strong> CS, <strong>(PWM)11:</strong> SDI, <strong>(PWM)12</strong> SDO, <strong>(PWM)13</strong> SCK.</p>
              <pre><code>
          void setup() {
            Serial.begin(9600);
          }
          
          void loop() {
            int sensorValue = analogRead(A0);
            Serial.println(sensorValue);
            delay(1000);
          }
              </code></pre>
          
              <p><strong>Result:</strong> 19:36:09.167 -> Temperature = 22.46 *C <br/> 19:36:09.167 -> Pressure = 101981.96 Pa <br/> 19:36:09.199 -> Approx altitude = -54.55 m</p>
              </details>
            <details>

            <summary><strong>Code 2: LED Backpack Counter Test</strong></summary>
              <p><strong>Setup:</strong> Same sensor, LED connected to pin 13.</p>
              <pre><code>

              #include <Wire.h>
              #include <TimerOne.h> // Timer1 documentation: https://www.pjrc.com/teensy/td_libs_TimerOne.html
              #include <Adafruit_LEDBackpack.h> // Search Arduino Library manager for "Adafruit LED Backpack Library“ for 7-segment LED.
              
              Adafruit_7segment matrix = Adafruit_7segment();
              unsigned int timerCount = 0; // global variable needed to increment by one
              void secondElapsed() {
                timerCount++;
                matrix.print(timerCount);
              }

              void setup() {
                matrix.begin(0x70); // Creates a serial connection to 7-segment display with the address "0x70"
                Timer1.initialize(1000000); // Initializes the timer to count every 1 000 000 microseconds i.e. one second
                Timer1.attachInterrupt(secondElapsed); // Triggers interrupt every time timer counts
              }

              void loop() {
                matrix.writeDisplay();
              }
                  
              </code></pre>
            <p><strong>Result:</strong> LED turns on when sensor value crosses 500.</p>
            </details>
          
            <details>
            <summary><strong>Code 3: GPS Module Test</strong></summary>
              <p><strong>Setup:</strong></p>
              <pre><code>
#define PPS_PIN 2 // The pin we're attaching to the PPS signal from the GPS unit
 volatile unsigned int overflows = 0;
 volatile unsigned int overflowsSincePPS = 0;
 volatile unsigned int lastTimer1 = 0;
 volatile bool recentPPS = false;
 ISR(TIMER1_OVF_vect) // This is called whenever Timer/Counter 1 overflows
{
 overflows++; // Increases the "overflows" variable by 1
}
void setup() {
 Serial.begin(115200);
 delay(1000);
 pinMode(PPS_PIN, INPUT);
 TCCR1A = 0; // Sets entire TCCR1A--Timer1 Control Register A--to 0
 TCCR1B = bit(CS10); // Turns on the Timer1 clock and sets it to increment every clock cycle 
 TCCR1C = 0; // Timer 1 Control Register C set to 0
 TCNT1 = 0; // Initialize timer/counter 1's value to 0
 TIMSK1 = bit(TOIE1); // Timer/Counter1's interrupt mask register; TOIE1 is the timer/Counter1 overflow interrupt enable
 Serial.println("Starting up...");
 attachInterrupt(digitalPinToInterrupt(PPS_PIN), PPSHandler, RISING);
}
void PPSHandler() { // Since this is an interrupt we should do as little as possible here. Serial writes take a lot of clock cycles, so we save that for the loop.
 lastTimer1 = TCNT1; 
 TCNT1 = 0; // Resets Timer1 Count
 overflowsSincePPS = overflows;
 overflows = 0;
 recentPPS = true;
}
void loop(){
 if (recentPPS) {
  noInterrupts();
  uint32_t overflowsTemp = overflowsSincePPS;
  uint32_t lastTimerTemp = lastTimer1;
  interrupts();
  Serial.print("Overflow:");
  Serial.println(overflowsTemp);
  Serial.print("Timer1:");
  Serial.println(lastTimerTemp);
  Serial.print("ClockCycles:");
  Serial.println(overflowsTemp << 16 | lastTimerTemp); // Equivalent to overflowsTemp * 2^16 + lastTimerTemp
 recentPPS = false;
 }
}

              </code></pre>
            <p><strong>Result:</strong> </p>
            </details>

            <details>
            <summary><strong>Code 4: Pulse Generator Test</strong></summary>
              <p><strong>Setup:</strong></p>
              <pre><code>
                #include <SPI.h> // Allows you to communicate with SPI (Serial Peripheral Interface) devices, with the Arduino as the master device
                  #include <Wire.h> // Enable this line if using Arduino Uno, Mega, etc.
                  // Signal pins are given a name, Global variables
                  #define triggerPin 2 // Trigger signal pin
                  // Interrupt service routine
                  // This function must be implemented, so that the TCNT1 counter counts
                  ISR(TIMER1_OVF_vect)
                  {
                  }
                  // All Arduino programs must contain a setup() and loop() functions
                  void setup() {
                  Serial.begin(115200); // Starts the serial monitor, sets baudrate to "115200" BPS
                  pinMode(triggerPin,INPUT); // Sets the digital pin 2 as an input
                  delay(1000); // Pauses the program for one second at the moment of open
                  // Initializes the Timer1 registers (16-bit timer -- counts from 0 to 65535 ad nauseam). Timer interrupts/pauses the execution of the loop() function for a predefined number of seconds.
                  // Timer1 is a 16-bit timer, so the timer will increase its value until it reaches its maximum count before reverting to 0. This enables the program to run a different set of commands. Once executed, the program resumes at the same position.
                  TCCR1A = 0; // Sets entire TCCR1A--Timer1 Control Register A--to 0
                  TCCR1B = 0; // Timer 1 Control Register B set to 0 (The physical address of timer1)
                  TCCR1C = 0; // Timer 1 Control Register C set to 0
                  TCNT1 = 0; // Initialize timer/counter 1's value to 0
                  TIMSK1 = _BV(TOIE1); // Timer/Counter1's interrupt mask register; TOIE1 is the timer/Counter1 overflow interrupt enable
                  TCCR1B = 1; // Timer 1 Control Register B set to 1
                  attachInterrupt(digitalPinToInterrupt(triggerPin), Trigger, RISING); // Interrupts execution of the program when a trigger signal is received. The "Trigger" function is subsequently executed
                  }
                  void Trigger(){
                  unsigned int temp = TCNT1; // Only positive integers are required
                  Serial.print("TCNT1 value: ");
                  Serial.println(temp); // Prints the value stored at temp
                  }
                  void loop() {
                  // No lines are necessary here
                  }
                             
              </code></pre>
            <p><strong>Result:</strong></p>
            </details>
    
      <h4 id="arduino-part3">Part 3 - Examining Relationship Between Baud Rate and Accuracy</h4>
      <p>Using the Pulse Generator Test code to adjust the baud rate and the frequency from the pulse generator.</p>
      <p>Below is the poster I presented in Queensborough Community College Undergraduate Research Day</p>
      <p><a href="SeanTai_ArduinoResearchPPT.pdf" target="_blank">View Arduino Research Slides (PDF)</a></p>
      <p>After this step, I noticed a pattern of patterns like shown below</p>

      <p>Then I used the code below to test</p>]
      <pre><code>

      </code></pre>


      <h4 id="arduino-part4">Part 4 - Measuring The Voltage</h4>
      <p>...</p>
      
      <h4>Reflection</h4>
      <p>This multi-part journey helped me understand hardware and C++ better.</p>
    </section>



    <!-- App Project Subsection -->
    <section id="app">
      <h3>App Development</h3>
      <p>Details about your app development project...</p>
      <h4>Reflection</h4>
      <p>Your reflection about the app development project goes here.</p>
    </section>

    <!-- General Reflections Section -->
    <section id="reflections">
      <h2>General Reflections</h2>
      <p>Other reflections or insights can be placed here.</p>
    </section>

  </body>
</html>